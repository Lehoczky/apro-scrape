<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Apro Scraper</title>
    <link rel="stylesheet" href="index.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>

  <body>
    <div class="container" id="app">
      <div class="row mt-20">
        <form
          class="col s12"
          @submit.prevent="startScraping($event)"
          novalidate
        >
          <div class="input-field">
            <input
              v-model="url"
              ref="input"
              placeholder="Enter HardverApro URL"
              :disabled="scraping"
            />
            <span ref="urlError" class="helper-text"></span>
          </div>

          <p class="range-field">
            <label for="range">Scarping interval (seconds)</label>
            <input
              v-model="scrapeInterval"
              id="interval"
              type="range"
              min="5"
              max="600"
              step="5"
              :disabled="scraping"
            />
          </p>

          <div class="right-align">
            <button
              v-show="history.length"
              class="btn waves-effect waves-light mr-8"
              @click.prevent="toggleHistory()"
            >
              History
            </button>

            <button
              v-if="!scraping"
              class="btn waves-effect waves-light"
              type="submit"
            >
              Scrape
            </button>
            <button
              v-else
              class="btn waves-effect waves-light red"
              @click.prevent="stopScraping()"
            >
              Stop
            </button>
          </div>
        </form>
      </div>

      <transition name="fade-from-top">
        <div v-show="showHistory" class="row collection">
          <a
            v-for="link in history"
            class="collection-item small-font waves-effect waves-teal"
            @click="chooseHistoryLink(link)"
          >
            {{link}}
          </a>
        </div>
      </transition>

      <section v-for="message in messages" class="row">
        <div class="card">
          <div class="card-content">
            <span class="card-title">
              {{ dateIntervalForMessage(message) }}
            </span>
            <table class="highlight">
              <tbody>
                <tr v-for="item in message" :key="item.url">
                  <td>
                    <a :href="item.url" @click.prevent="openExternal(item.url)">
                      {{ item.title }}
                    </a>
                  </td>
                  <td class="price">{{ item.price }}</td>
                  <td class="location hide-on-small-only">
                    {{ item.location }}
                  </td>
                  <td class="date hide-on-small-only">{{ item.updated }}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>
    </div>
  </body>
  <script>
    const remote = require("electron").remote;
    const { ipcRenderer, shell } = require("electron");
    const { createScraper } = remote.require("./scrape");

    const mainWindow = remote.getCurrentWindow();
    const scrape = createScraper();

    const startInterval = (seconds, callback) => {
      callback();
      return setInterval(callback, seconds * 1000);
    };

    const app = new Vue({
      el: "#app",
      data: {
        url: "",
        scraping: false,
        scrapeInterval: 60,
        showHistory: false,
        history: [],
        messages: [],
        interval: undefined,
      },
      created() {
        this.history = JSON.parse(localStorage.getItem("history")) || [];
      },
      mounted() {
        const sliders = document.querySelectorAll("input[type=range]");
        M.Range.init(sliders);
      },
      methods: {
        async startScraping(event) {
          const errorMessage = await this.validateUrlInput();
          if (errorMessage) {
            this.$refs.input.classList.add("invalid");
            this.$refs.urlError.dataset.error = errorMessage;
          } else {
            this.$refs.input.classList.remove("invalid");
            this.scraping = true;
            this.showHistory = false;
            this.addToHistory(this.url);

            this.interval = startInterval(this.scrapeInterval, async () => {
              const items = await scrape(this.url);
              console.log(items.length);
              if (items.length) {
                this.messages = [items, ...this.messages];
                if (true || !mainWindow.isVisible()) {
                  const title =
                    items.length == 1
                      ? "New item is available"
                      : "New items are available";
                  const body =
                    items.length == 1
                      ? `${items[0].title} - ${items[0].price}`
                      : `${items.length} new items found!`;

                  const myNotification = new Notification(title, { body });

                  myNotification.onclick = () => {
                    mainWindow.show();
                  };
                }
              }
            });
          }
        },
        stopScraping() {
          this.scraping = false;
          clearInterval(this.interval);
          this.interval = undefined;
        },
        async validateUrlInput() {
          if (this.url == "") {
            return "Please fill out this field";
          } else if (!this.url.startsWith("https://hardverapro.hu")) {
            return "Please provide a link to hardverapro.hu";
          } else {
            const response = await fetch(this.url, {
              method: "HEAD",
            });
            if (response.status == 404) {
              return "The page does not exist, please check the URL";
            }
            return "";
          }
        },
        dateIntervalForMessage(message) {
          const lastDate = message[message.length - 1].updated;
          const firstDate = message[0].updated;
          return `${lastDate} - ${firstDate}`;
        },
        toggleHistory() {
          this.showHistory = !this.showHistory;
        },
        chooseHistoryLink(link) {
          if (!this.scraping) {
            this.url = link;
          }
        },
        addToHistory(link) {
          if (this.history.includes(link)) {
            this.history.splice(this.history.indexOf(link), 1);
          }
          this.history = [link, ...this.history.slice(0, 4)];
        },
        openExternal(url) {
          shell.openExternal(url);
        },
      },
      watch: {
        history(newValue, oldValue) {
          localStorage.setItem("history", JSON.stringify(newValue));
        },
      },
    });
  </script>
</html>
